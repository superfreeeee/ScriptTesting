# LeetCode題目  
  
## 1. 兩數和  
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。  
  
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。  
  
示例:  
```  
给定 nums = [2, 7, 11, 15], target = 9  
  
因为 nums[0] + nums[1] = 2 + 7 = 9  
所以返回 [0, 1]  
```  
  
## 2. 兩數相加  
给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。  
  
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。  
  
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。  
  
示例：  
```  
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)  
输出：7 -> 0 -> 8  
原因：342 + 465 = 807  
```  
  
## 3. 无重复字符的最长子串  
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。  
  
示例 1:  
```  
输入: "abcabcbb"  
输出: 3  
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。  
```  
示例 2:  
```  
输入: "bbbbb"  
输出: 1  
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。  
```  
示例 3:  
```  
输入: "pwwkew"  
输出: 3  
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。  
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。  
```  
  
## 4. 寻找两个有序数组的中位数  
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。  
  
请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。  
  
你可以假设 nums1 和 nums2 不会同时为空。  
  
示例 1:  
```  
nums1 = [1, 3]  
nums2 = [2]  
  
则中位数是 2.0  
```  
示例 2:  
```  
nums1 = [1, 2]  
nums2 = [3, 4]  
  
则中位数是 (2 + 3)/2 = 2.5  
```  
  
## 5. 最长回文子串  
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。  
  
示例 1：  
```  
输入: "babad"  
输出: "bab"  
注意: "aba" 也是一个有效答案。  
```  
示例 2：  
```  
输入: "cbbd"  
输出: "bb"  
```  
  
## 6. Z 字形变换  
将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。  
  
比如输入字符串为 "LEETCODEISHIRING" 行数为 3 时，排列如下：  
  
L   C   I   R  
E T O E S I I G  
E   D   H   N  
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："LCIRETOESIIGEDHN"。  
  
请你实现这个将字符串进行指定行数变换的函数：  
  
string convert(string s, int numRows);  
  
示例 1:  
```  
输入: s = "LEETCODEISHIRING", numRows = 3  
输出: "LCIRETOESIIGEDHN"  
```  
示例 2:  
```  
输入: s = "LEETCODEISHIRING", numRows = 4  
输出: "LDREOEIIECIHNTSG"  
解释:  
  
L     D     R  
E   O E   I I  
E C   I H   N  
T     S     G  
```  
  
## 7. 整数反转  
反转。  
  
示例 1:  
```  
输入: 123  
输出: 321  
```  
示例 2:  
```  
输入: -123  
输出: -321  
示例 3:  
  
输入: 120  
输出: 21  
```  
注意:  
  
假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。  
  
## 8. 字符串转换整数 (atoi)  
请你来实现一个 atoi 函数，使其能将字符串转换成整数。  
  
首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。  
  
当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。  
  
该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。  
  
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。  
  
在任何情况下，若函数不能进行有效的转换时，请返回 0。  
  
说明：  
  
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。  
  
示例 1:  
```  
输入: "42"  
输出: 42  
```  
示例 2:  
```  
输入: "   -42"  
输出: -42  
解释: 第一个非空白字符为 '-', 它是一个负号。  
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。  
```  
示例 3:  
```  
输入: "4193 with words"  
输出: 4193  
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。  
```  
示例 4:  
```  
输入: "words and 987"  
输出: 0  
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。  
     因此无法执行有效的转换。  
```  
示例 5:  
```  
输入: "-91283472332"  
输出: -2147483648  
解释: 数字 "-91283472332" 超过 32 位有符号整数范围。  
     因此返回 INT_MIN (−231) 。  
```  
  
## 9. 回文數  
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。  
  
示例 1:  
```  
输入: 121  
输出: true  
```  
示例 2:  
```  
输入: -121  
输出: false  
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。  
```  
示例 3:  
```  
输入: 10  
输出: false  
解释: 从右向左读, 为 01 。因此它不是一个回文数。  
```  
进阶:  
  
你能不将整数转为字符串来解决这个问题吗？  
  
## 10. 正则表达式匹配  
给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。  
  
'.' 匹配任意单个字符  
'*' 匹配零个或多个前面的那一个元素  
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。  
  
说明:  
  
s 可能为空，且只包含从 a-z 的小写字母。  
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。  
  
示例 1:  
```  
输入:  
s = "aa"  
p = "a"  
输出: false  
解释: "a" 无法匹配 "aa" 整个字符串。  
```  
示例 2:  
```  
输入:  
s = "aa"  
p = "a*"  
输出: true  
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。  
```  
示例 3:  
```  
输入:  
s = "ab"  
p = ".*"  
输出: true  
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。  
```  
示例 4:  
```  
输入:  
s = "aab"  
p = "c*a*b"  
输出: true  
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。  
```  
示例 5:  
```  
输入:  
s = "mississippi"  
p = "mis*is*p*."  
输出: false  
```  
  
## 11.  
  
## 12.  
  
## 13. 罗马数字转整数  
罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。  
  
字符          数值  
I             1  
V             5  
X             10  
L             50  
C             100  
D             500  
M             1000  
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。  
  
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：  
  
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。  
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。   
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。  
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。  
  
示例 1:  
```  
输入: "III"  
输出: 3  
```  
示例 2:  
```  
输入: "IV"  
输出: 4  
```  
示例 3:  
```  
输入: "IX"  
输出: 9  
```  
示例 4:  
```  
输入: "LVIII"  
输出: 58  
解释: L = 50, V= 5, III = 3.  
```  
示例 5:  
```  
输入: "MCMXCIV"  
输出: 1994  
解释: M = 1000, CM = 900, XC = 90, IV = 4.  
```  
  
## 14. 最长公共前缀  
编写一个函数来查找字符串数组中的最长公共前缀。  
  
如果不存在公共前缀，返回空字符串 ""。  
  
示例 1:  
```  
输入: ["flower","flow","flight"]  
输出: "fl"  
```  
示例 2:  
```  
输入: ["dog","racecar","car"]  
输出: ""  
解释: 输入不存在公共前缀。  
```  
说明:  
  
所有输入只包含小写字母 a-z 。  
  
## 15.  
  
## 16.  
  
## 17.  
  
## 18.  
  
## 19.  
  
## 20. 有效的括号  
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。  
  
有效字符串需满足：  
  
左括号必须用相同类型的右括号闭合。  
左括号必须以正确的顺序闭合。  
注意空字符串可被认为是有效字符串。  
  
示例 1:  
```  
输入: "()"  
输出: true  
```  
示例 2:  
```  
输入: "()[]{}"  
输出: true  
```  
示例 3:  
```  
输入: "(]"  
输出: false  
```  
示例 4:  
```  
输入: "([)]"  
输出: false  
```  
示例 5:  
```  
输入: "{[]}"  
输出: true  
```  
  
## 21. 合并两个有序链表  
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。   
  
示例：  
```  
输入：1->2->4, 1->3->4  
输出：1->1->2->3->4->4  
```  
  
## 22.  
  
## 23.  
  
## 24.  
  
## 25.  
  
## 26. 删除排序数组中的重复项  
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。  
  
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。  
  
示例 1:  
```  
给定数组 nums = [1,1,2],  
  
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。  
  
你不需要考虑数组中超出新长度后面的元素。  
```  
示例 2:  
```  
给定 nums = [0,0,1,1,1,2,2,3,3,4],  
  
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。  
  
你不需要考虑数组中超出新长度后面的元素。  
```  
说明:  
  
为什么返回数值是整数，但输出的答案是数组呢?  
  
请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。  
  
你可以想象内部操作如下:  
```java  
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝  
int len = removeDuplicates(nums);  
  
// 在函数里修改输入数组对于调用者是可见的。  
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。  
for (int i = 0; i < len; i++) {  
    print(nums[i]);  
}  
```  
  
## 27. 移除元素  
给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。  
  
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。  
  
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。  
  
示例 1:  
```  
给定 nums = [3,2,2,3], val = 3,  
  
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。  
  
你不需要考虑数组中超出新长度后面的元素。  
```  
示例 2:  
```  
给定 nums = [0,1,2,2,3,0,4,2], val = 2,  
  
函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。  
  
注意这五个元素可为任意顺序。  
  
你不需要考虑数组中超出新长度后面的元素。  
```  
说明:  
  
为什么返回数值是整数，但输出的答案是数组呢?  
  
请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。  
  
你可以想象内部操作如下:  
```java  
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝  
int len = removeElement(nums, val);  
  
// 在函数里修改输入数组对于调用者是可见的。  
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。  
for (int i = 0; i < len; i++) {  
    print(nums[i]);  
}  
```  
  
## 28. 实现 strStr()  
实现 strStr() 函数。  
  
给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。  
  
示例 1:  
```  
输入: haystack = "hello", needle = "ll"  
输出: 2  
```  
示例 2:  
```  
输入: haystack = "aaaaa", needle = "bba"  
输出: -1  
```  
说明:  
  
当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。  
  
对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。  
  
## 29.  
  
## 30.  
  
## 31.  
  
## 32.  
  
## 33.  
  
## 34.  
  
## 35. 搜索插入位置  
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。  
  
你可以假设数组中无重复元素。  
  
示例 1:  
```  
输入: [1,3,5,6], 5  
输出: 2  
```  
示例 2:  
```  
输入: [1,3,5,6], 2  
输出: 1  
```  
示例 3:  
```  
输入: [1,3,5,6], 7  
输出: 4  
```  
示例 4:  
```  
输入: [1,3,5,6], 0  
输出: 0  
```  
  
## 36.  
  
## 37.  
  
## 38. 报数  
报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：  
```  
1.     1  
2.     11  
3.     21  
4.     1211  
5.     111221  
```  
1 被读作  "one 1"  ("一个一") , 即 11。  
11 被读作 "two 1s" ("两个一"）, 即 21。  
21 被读作 "one 2",  "one 1" （"一个二" ,  "一个一") , 即 1211。  
  
给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。  
  
注意：整数顺序将表示为一个字符串。  
  
示例 1:  
```  
输入: 1  
输出: "1"  
```  
示例 2:  
```  
输入: 4  
输出: "1211"  
```  
  
## 39.  
  
## 40.  
  
## 41.  
  
## 42.  
  
## 43.  
  
## 44.  
  
## 45.  
  
## 46.  
  
## 47.  
  
## 48.  
  
## 49.  
  
## 50.  
  
## 51.  
  
## 52.  
  
## 53. 最大子序和  
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。  
  
示例:  
```  
输入: [-2,1,-3,4,-1,2,1,-5,4],  
输出: 6  
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。  
```  
进阶:  
  
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。  
  
## 54.  
  
## 55.  
  
## 56.  
  
## 57.  
  
## 58. 最后一个单词的长度  
给定一个仅包含大小写字母和空格 ' ' 的字符串，返回其最后一个单词的长度。  
  
如果不存在最后一个单词，请返回 0 。  
  
说明：一个单词是指由字母组成，但不包含任何空格的字符串。  
  
示例:  
```  
输入: "Hello World"  
输出: 5  
```  
  
## 59.  
  
## 60.  
  
## 61.  
  
## 62.  
  
## 63.  
  
## 64.  
  
## 65.  
  
## 66. 加一  
给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。  
  
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。  
  
你可以假设除了整数 0 之外，这个整数不会以零开头。  
  
示例 1:  
```  
输入: [1,2,3]  
输出: [1,2,4]  
解释: 输入数组表示数字 123。  
```  
示例 2:  
```  
输入: [4,3,2,1]  
输出: [4,3,2,2]  
解释: 输入数组表示数字 4321。  
```  
  
## 67. 二进制求和  
给定两个二进制字符串，返回他们的和（用二进制表示）。  
  
输入为非空字符串且只包含数字 1 和 0。  
  
示例 1:  
```  
输入: a = "11", b = "1"  
输出: "100"  
```  
示例 2:  
```  
输入: a = "1010", b = "1011"  
输出: "10101"  
```  
  
## 68.  
  
## 69. x 的平方根  
实现 int sqrt(int x) 函数。  
  
计算并返回 x 的平方根，其中 x 是非负整数。  
  
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。  
  
示例 1:  
```  
输入: 4  
输出: 2  
```  
示例 2:  
```  
输入: 8  
输出: 2  
说明: 8 的平方根是 2.82842...,  
     由于返回类型是整数，小数部分将被舍去。  
```  
  
## 70. 爬楼梯  
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。  
  
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？  
  
注意：给定 n 是一个正整数。  
  
示例 1：  
```  
输入： 2  
输出： 2  
解释： 有两种方法可以爬到楼顶。  
1.  1 阶 + 1 阶  
2.  2 阶  
```  
示例 2：  
```  
输入： 3  
输出： 3  
解释： 有三种方法可以爬到楼顶。  
1.  1 阶 + 1 阶 + 1 阶  
2.  1 阶 + 2 阶  
3.  2 阶 + 1 阶  
```  
  
## 71.  
  
## 72.  
  
## 73.  
  
## 74.  
  
## 75.  
  
## 76.  
  
## 77.  
  
## 78.  
  
## 79.  
  
## 80.  
  
## 81.  
  
## 82.  
  
## 83. 删除排序链表中的重复元素  
给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。  
  
示例 1:  
```  
输入: 1->1->2  
输出: 1->2  
```  
示例 2:  
```  
输入: 1->1->2->3->3  
输出: 1->2->3  
```  
  
## 84.  
  
## 85.  
  
## 86.  
  
## 87.  
  
## 88. 合并两个有序数组  
给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。  
  
说明:  
  
初始化 nums1 和 nums2 的元素数量分别为 m 和 n。  
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。  
示例:  
```  
输入:  
nums1 = [1,2,3,0,0,0], m = 3  
nums2 = [2,5,6],       n = 3  
  
输出: [1,2,2,3,5,6]  
```  
  
## 89.  
  
## 90.  
  
## 91.  
  
## 92.  
  
## 93.  
  
## 94.  
  
## 95.  
  
## 96.  
  
## 97.  
  
## 98.  
  
## 99.  
  
## 100. 相同的树  
给定两个二叉树，编写一个函数来检验它们是否相同。  
  
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。  
  
示例 1:  
```  
输入:       1         1  
          / \       / \  
         2   3     2   3  
  
        [1,2,3],   [1,2,3]  
  
输出: true  
```  
示例 2:  
```  
输入:      1          1  
          /           \  
         2             2  
  
        [1,2],     [1,null,2]  
  
输出: false  
```  
示例 3:  
```  
输入:       1         1  
          / \       / \  
         2   1     1   2  
  
        [1,2,1],   [1,1,2]  
  
输出: false  
```  
  
## 101. 对称二叉树  
给定一个二叉树，检查它是否是镜像对称的。  
  
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。  
```  
    1  
   / \  
  2   2  
 / \ / \  
3  4 4  3  
```  
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:  
```  
    1  
   / \  
  2   2  
   \   \  
   3    3  
```  
说明:  
  
如果你可以运用递归和迭代两种方法解决这个问题，会很加分。  
  
## 102.  
  
## 103.  
  
## 104. 二叉树的最大深度  
给定一个二叉树，找出其最大深度。  
  
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。  
  
说明: 叶子节点是指没有子节点的节点。  
  
示例：  
给定二叉树 [3,9,20,null,null,15,7]，  
```  
    3  
   / \  
  9  20  
    /  \  
   15   7  
```  
返回它的最大深度 3 。  
  
## 105.  
  
## 106.  
  
## 107. 二叉树的层次遍历 II  
给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）  
  
例如：  
给定二叉树 [3,9,20,null,null,15,7],  
```  
    3  
   / \  
  9  20  
    /  \  
   15   7  
```  
返回其自底向上的层次遍历为：  
```  
[  
  [15,7],  
  [9,20],  
  [3]  
]  
```  
  
## 108. 将有序数组转换为二叉搜索树  
将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。  
  
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。  
  
示例:  
  
给定有序数组: [-10,-3,0,5,9],  
  
一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：  
```  
      0  
     / \  
   -3   9  
   /   /  
 -10  5  
```  
  
## 109.  
  
## 110. 平衡二叉树
给定一个二叉树，判断它是否是高度平衡的二叉树。  
  
本题中，一棵高度平衡二叉树定义为：  
  
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。  
  
示例 1:  
  
给定二叉树 `[3,9,20,null,null,15,7]`  
```  
    3  
   / \  
  9  20  
    /  \  
   15   7  
```  
返回 true 。  
  
示例 2:  
  
给定二叉树 `[1,2,2,3,3,null,null,4,4]`  
```  
       1  
      / \  
     2   2  
    / \  
   3   3  
  / \  
 4   4  
```  
返回 false 。  
  
## 111. 二叉树的最小深度
给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

示例:

给定二叉树 [3,9,20,null,null,15,7],
```
    3
   / \
  9  20
    /  \
   15   7
```
返回它的最小深度  2.

## 112. 路径总和

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例: 
给定如下二叉树，以及目标和 sum = 22，
```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
```
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。

## 113. 

## 114. 

## 115. 

## 116. 

## 117. 

## 118. 杨辉三角
给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。

在杨辉三角中，每个数是它左上方和右上方的数的和。

示例:
```
输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

## 119. 杨辉三角 II
给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。

在杨辉三角中，每个数是它左上方和右上方的数的和。

示例:
```
输入: 3
输出: [1,3,3,1]
进阶：
```
你可以优化你的算法到 O(k) 空间复杂度吗？

## 120.

## 121. 买卖股票的最佳时机
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

示例 1:
```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```
示例 2:
```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```
  
## 122. 买卖股票的最佳时机 II
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:
```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```
示例 2:
```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```
示例 3:
```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```
  
## 123.
  
## 124.
  
## 125. 验证回文串
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

说明：本题中，我们将空字符串定义为有效的回文串。

示例 1:
```
输入: "A man, a plan, a canal: Panama"
输出: true
```
示例 2:
```
输入: "race a car"
输出: false
```

## 126. 

## 127. 

## 128. 

## 129. 

## 130. 

## 131. 

## 132. 

## 133. 

## 134. 

## 135. 

## 136. 只出现一次的数字
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:
```
输入: [2,2,1]
输出: 1
```
示例 2:
```
输入: [4,1,2,1,2]
输出: 4
```

## 137.

## 138.

## 139.

## 140.

## 141. 环形链表
给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

示例 1：
```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```
示例 2：
```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```
示例 3：
```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```
进阶：

你能用 O(1)（即，常量）内存解决此问题吗？

## 142.

## 143.

## 144.

## 145.

## 146.

## 147.

## 148.

## 149.

## 150.

## 151.

## 152.

## 153.

## 154.

## 155. 最小栈
设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。
```
push(x) -- 将元素 x 推入栈中。
pop() -- 删除栈顶的元素。
top() -- 获取栈顶元素。
getMin() -- 检索栈中的最小元素。
```
示例:
```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

## 156.

## 157.

## 158.

## 159.

## 160.

## 161.

## 162.

## 163.

## 164.

## 165.

## 166.

## 167.

## 168.

## 169.

## 170.

## 171.

## 172.

## 173.

## 174.

## 175. 组合两个表
表1: Person
```sql
+-------------+---------+
| 列名         | 类型     |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId 是上表主键
```
表2: Address
```sql
+-------------+---------+
| 列名         | 类型    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId 是上表主键
```
编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：
```
FirstName, LastName, City, State
```





  
  
  
  
